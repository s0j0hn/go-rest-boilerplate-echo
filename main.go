package main

import (
	"github.com/casbin/casbin/v2"
	defaultrolemanager "github.com/casbin/casbin/v2/rbac/default-role-manager"
	"github.com/casbin/casbin/v2/util"
	gormadapter "github.com/casbin/gorm-adapter/v2"
	_ "github.com/go-sql-driver/mysql"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/swaggo/echo-swagger"
	"gitlab.com/s0j0hn/go-rest-boilerplate-echo/config"
	"gitlab.com/s0j0hn/go-rest-boilerplate-echo/database"
	tenantModel "gitlab.com/s0j0hn/go-rest-boilerplate-echo/database/models/tenant"
	_ "gitlab.com/s0j0hn/go-rest-boilerplate-echo/docs" // docs is generated by Swag CLI, you have to import it.
	tenantHandler "gitlab.com/s0j0hn/go-rest-boilerplate-echo/handlers"
	"golang.org/x/crypto/acme/autocert"
	"gopkg.in/go-playground/validator.v9"

	"log"
)

type (
	CustomValidator struct {
		validator *validator.Validate
	}
	PolicyEnforcer struct {
		enforcer *casbin.Enforcer
	}
)

func (cv *CustomValidator) Validate(i interface{}) error {
	return cv.validator.Struct(i)
}

func (e *PolicyEnforcer) checkPolicyAccessGuests(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		user := "guest" // All unauthenticated requests only
		method := c.Request().Method
		path := c.Request().URL.Path

		isGood, err := e.enforcer.Enforce(user, path, method)
		if err != nil {
			log.Fatal(err)
			return echo.ErrForbidden
		}

		if isGood {
			return next(c)
		}
		return echo.ErrForbidden
	}
}

func main() {

	echoServer := echo.New()

	echoServer.Validator = &CustomValidator{validator: validator.New()}

	echoServer.Use(middleware.Recover())
	echoServer.Use(middleware.Logger())
	echoServer.Use(middleware.Secure())

	// Initialize a Gorm adapter and use it in a Casbin enforcer:
	// The adapter will use the MySQL database named "casbin".
	// If it doesn't exist, the adapter will create it automatically.
	casbinGormAdapter, err := gormadapter.NewAdapterByDB(database.Connect()) // Your driver and data source.
	if err != nil {
		log.Fatal(err)
	}

	// We need a new roleManager to force the route params verification ex: (/tenants/:id).
	var roleManager = defaultrolemanager.NewRoleManager(2)
	roleManager.(*defaultrolemanager.RoleManager).AddMatchingFunc("KeyMatch2", util.KeyMatch2)

	// Create Policy enforcer with our customized model.
	policyEnforcer, err := casbin.NewEnforcer("config/keymatch_model", casbinGormAdapter)
	if err != nil {
		log.Fatal(err)
	}

	policyEnforcer.SetRoleManager(roleManager)

	// We seed the DB with some policies.
	// policyEnforcer.AddPolicy("guest", "/tenants", "(GET)|(DELETE)|(POST)|(PUT)").
	isAdded, err := policyEnforcer.AddPolicy("guest", "/tenants/:id", "(GET)|(POST)")
	if err != nil {
		log.Fatal(err)
	}

	if isAdded {
		log.Print("New policy added successfully.")
	}

	// Logs for casbin.
	policyEnforcer.EnableLog(true)

	// Load the policy from DB.
	err = policyEnforcer.LoadPolicy()
	if err != nil {
		log.Fatal(err)
	}

	// Save the policy back to DB.
	err = policyEnforcer.SavePolicy()
	if err != nil {
		log.Fatal(err)
	}

	tenantInstance := tenantModel.TenantModel{}
	tenantHandlerInstance := tenantHandler.CreateHandler(tenantInstance)

	policyCheck := PolicyEnforcer{enforcer: policyEnforcer}

	// Apply the policy for all routes.
	echoServer.Use(policyCheck.checkPolicyAccessGuests)
	echoServer.GET("/swagger/*", echoSwagger.WrapHandler)
	echoServer.GET("/tenants", tenantHandlerInstance.GetAll)
	echoServer.GET("/tenants/:id", tenantHandlerInstance.GetOneById)
	echoServer.POST("/tenants", tenantHandlerInstance.Create)
	echoServer.PUT("/tenants", tenantHandlerInstance.Update)
	echoServer.DELETE("/tenants/:id", tenantHandlerInstance.DeleteById)

	if config.IsProd() {
		echoServer.AutoTLSManager.Cache = autocert.DirCache("./.cache")
		echoServer.Pre(middleware.HTTPSRedirect())
		go func(c *echo.Echo) {
			echoServer.Logger.Fatal(echoServer.Start(":80"))
		}(echoServer)
		echoServer.Logger.Fatal(echoServer.StartAutoTLS(":443"))
	} else {
		echoServer.Logger.Fatal(echoServer.Start(config.GetPort()))
	}
}
